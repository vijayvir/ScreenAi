<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>ScreenAI - Screen Sharing POC</title>
   <style>
       * {
           margin: 0;
           padding: 0;
           box-sizing: border-box;
       }
      
       body {
           font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
           background: linear-gradient(135deg, #689F38 0%, #33691E 100%);
           min-height: 100vh;
           color: white;
           overflow: hidden;
       }
      
       .control-panel {
           display: flex;
           align-items: center;
           justify-content: center;
           min-height: 100vh;
           padding: 20px;
           text-align: center;
           background: linear-gradient(135deg, #689F38 0%, #33691E 100%);
           color: white;
       }
      
       .container {
           max-width: 600px;
           text-align: center;
           padding: 40px 30px;
           background: rgba(255, 255, 255, 0.15);
           border-radius: 20px;
           backdrop-filter: blur(10px);
           border: 2px solid rgba(255, 255, 255, 0.3);
           box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
       }
      
       .logo {
           font-size: 3.5rem;
           font-weight: bold;
           margin-bottom: 20px;
           color: white;
           text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
       }
      
       .tagline {
           font-size: 1.3rem;
           margin-bottom: 30px;
           opacity: 0.9;
           line-height: 1.6;
       }
      
       .features {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
           gap: 20px;
           margin: 40px 0;
       }
      
       .feature {
           padding: 20px;
           background: rgba(255, 255, 255, 0.1);
           border-radius: 15px;
           border: 1px solid rgba(255, 255, 255, 0.2);
           transition: all 0.3s ease;
       }
      
       .feature:hover {
           transform: translateY(-5px);
           background: rgba(255, 255, 255, 0.15);
           box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
       }
      
       .feature-icon {
           font-size: 2rem;
           margin-bottom: 10px;
       }
      
       .feature h3 {
           margin-bottom: 10px;
           color: white;
           font-weight: 600;
       }
      
       .feature p {
           opacity: 0.8;
           line-height: 1.5;
       }
      
       /* Stream Viewer Styles */
       .stream-viewer {
           display: none;
           position: relative;
           width: 100vw;
           height: 100vh;
           background: #000;
       }
      
       /* Video element for H.264 streams */
       #videoView {
           width: 100%;
           height: 100%;
           object-fit: contain;
           background-color: #000;
           display: none;
       }
      
       /* Status and capture info boxes removed */
      
       /* Control panel styling merged with landing styles above */
      
       .control-panel h1 {
           font-size: 3rem;
           font-weight: bold;
           margin-bottom: 20px;
           color: white;
           text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
       }
      
       .control-status {
           background: rgba(255,255,255,0.15);
           padding: 20px;
           border-radius: 15px;
           margin: 30px auto;
           max-width: 400px;
           border: 2px solid rgba(255, 255, 255, 0.3);
           box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
       }
      
       .status-line {
           margin: 10px 0;
           font-size: 16px;
       }
      
       .status-value {
           color: #FFF;
           font-weight: bold;
           text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
       }
       
       /* Performance Metrics Styles */
       .performance-metrics {
           background: rgba(0, 0, 0, 0.4);
           padding: 15px;
           border-radius: 10px;
           margin-top: 20px;
           border: 1px solid rgba(139, 195, 74, 0.3);
       }
       
       .performance-metrics.hidden {
           display: none;
       }
       
       .metrics-title {
           font-size: 14px;
           font-weight: bold;
           margin-bottom: 12px;
           color: #8BC34A;
           text-shadow: 0 0 10px rgba(139, 195, 74, 0.5);
       }
       
       .metrics-row {
           display: grid;
           grid-template-columns: repeat(4, 1fr);
           gap: 10px;
       }
       
       .metric {
           background: rgba(255, 255, 255, 0.1);
           padding: 10px;
           border-radius: 8px;
           border: 1px solid rgba(255, 255, 255, 0.2);
       }
       
       .metric-label {
           font-size: 11px;
           opacity: 0.8;
           margin-bottom: 4px;
       }
       
       .metric-value {
           font-size: 16px;
           font-weight: bold;
           color: #8BC34A;
           font-family: 'Courier New', monospace;
           text-shadow: 0 0 8px rgba(139, 195, 74, 0.4);
       }
       
       .encoder-info {
           margin-top: 10px;
           font-size: 11px;
           opacity: 0.7;
           text-align: center;
       }
      
       .error {
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           color: white;
           text-align: center;
           background: rgba(0, 0, 0, 0.8);
           padding: 30px;
           border-radius: 10px;
           display: none;
       }
      
       .error button {
           background: linear-gradient(135deg, #7CB342 0%, #558B2F 100%);
           color: white;
           border: none;
           padding: 10px 20px;
           border-radius: 5px;
           cursor: pointer;
           margin-top: 15px;
           box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
       }
      
       .error button:hover {
           background: linear-gradient(135deg, #8BC34A 0%, #689F38 100%);
       }
      
       /* üïí Stream Timestamp Styles - Top Left Corner */
       .stream-timestamp {
           position: fixed;
           top: 20px;
           left: 20px;
           display: none;
           padding: 12px 16px;
           background: rgba(0, 0, 0, 0.85);
           border-radius: 8px;
           color: white;
           font-family: 'Courier New', monospace;
           font-size: 12px;
           line-height: 1.6;
           border: 1px solid rgba(139, 195, 74, 0.4);
           backdrop-filter: blur(10px);
           box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
           min-width: 180px;
           z-index: 1000;
       }

       .stream-timestamp.show {
           display: block;
       }

       .stream-timestamp-row {
           display: flex;
           align-items: center;
           justify-content: space-between;
           gap: 12px;
           margin: 6px 0;
       }

       .stream-timestamp-label {
           font-size: 11px;
           opacity: 0.8;
           color: #ccc;
           min-width: 70px;
       }

       .stream-timestamp-value {
           color: #8BC34A;
           font-weight: bold;
           font-size: 13px;
           text-align: right;
       }

       .stream-timestamp-value.elapsed {
           color: #FF9800;
           font-size: 14px;
           font-weight: bold;
           animation: pulse 2s ease-in-out infinite;
       }

       /* ‚è±Ô∏è Countdown Timer Styles */
       .stream-timestamp-value.countdown {
           color: #2196F3;
           font-size: 16px;
           font-weight: bold;
       }

       .stream-timestamp-value.countdown.warning {
           color: #FF9800;
           animation: pulse 1s ease-in-out infinite;
       }

       .stream-timestamp-value.countdown.critical {
           color: #F44336;
           animation: pulse 0.5s ease-in-out infinite;
       }
      
       @keyframes pulse {
           0%, 100% { opacity: 1; }
           50% { opacity: 0.6; }
       }
      
       /* Button Styles */
       .btn {
           padding: 15px 30px;
           margin: 10px;
           border: none;
           border-radius: 10px;
           cursor: pointer;
           font-size: 18px;
           font-weight: bold;
           transition: all 0.3s;
           min-width: 180px;
       }
      
       .btn-lg {
           padding: 20px 40px;
           font-size: 20px;
           min-width: 220px;
       }
      
       .btn:hover {
           transform: translateY(-2px);
           box-shadow: 0 6px 20px rgba(0,0,0,0.3);
       }
      
       .btn:disabled {
           opacity: 0.6;
           cursor: not-allowed;
           transform: none;
       }
      
       .btn-success {
           background: linear-gradient(135deg, #7CB342 0%, #558B2F 100%);
           color: white;
           box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
       }
      
       .btn-success:hover {
           background: linear-gradient(135deg, #8BC34A 0%, #689F38 100%);
           box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
       }
      
       .btn-danger {
           background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
           color: white;
           box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
       }
      
       .btn-danger:hover {
           background: linear-gradient(135deg, #e53935 0%, #c62828 100%);
       }
      
       .btn-secondary {
           background: #6c757d;
           color: white;
       }
      
       .btn-primary {
           background: linear-gradient(45deg, #7CB342, #558B2F);
           color: white;
           border: none;
           box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
       }
      
       .loading {
           display: inline-block;
           animation: spin 1s linear infinite;
       }
      
       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }
      
       .hidden {
           display: none !important;
       }
      
       /* Stream Controls */
       .stream-controls {
           position: fixed;
           bottom: 30px;
           left: 50%;
           transform: translateX(-50%);
           display: none;
           align-items: center;
           z-index: 1001;
           background: rgba(0, 0, 0, 0.7);
           padding: 15px;
           border-radius: 12px;
           border: 1px solid rgba(255, 255, 255, 0.2);
           backdrop-filter: blur(10px);
           box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
       }
      
       .stream-controls.show {
           display: flex !important;
       }


       /* Session Summary on Home Screen */
       .session-results {
           position: fixed;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           background: rgba(0, 0, 0, 0.95);
           padding: 30px;
           border-radius: 15px;
           border: 2px solid #8BC34A;
           color: white;
           min-width: 400px;
           max-width: 500px;
           z-index: 2000;
           backdrop-filter: blur(15px);
           box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
       }


       .session-results h3 {
           color: #8BC34A;
           margin-bottom: 20px;
           text-align: center;
           font-size: 20px;
           border-bottom: 1px solid rgba(139, 195, 74, 0.3);
           padding-bottom: 10px;
       }


       .session-detail {
           display: flex;
           justify-content: space-between;
           margin: 12px 0;
           padding: 10px 0;
           border-bottom: 1px solid rgba(255, 255, 255, 0.1);
           font-size: 15px;
       }


       .session-detail:last-child {
           border-bottom: none;
       }


       .session-detail-label {
           opacity: 0.9;
           font-weight: 500;
       }


       .session-detail-value {
           color: #8BC34A;
           font-family: 'Courier New', monospace;
           font-weight: bold;
       }


       .session-duration {
           color: #FF9800 !important;
           font-size: 18px !important;
       }


       /* Mobile responsive */
       @media (max-width: 768px) {
           .stream-timestamp {
               display: block;
               margin: 0 auto 15px auto;
               font-size: 10px;
               padding: 6px 10px;
           }
          
           .stream-timestamp-value.elapsed {
               font-size: 11px;
           }
          
           .session-results {
               min-width: 300px;
               padding: 20px;
           }
       }
   </style>
</head>
<body>
   <!-- Screen AI Control Center as Landing Page -->
   <div id="controlPanel" class="control-panel">
       <div class="container">
           <h1>üé• Screen AI</h1>
          
           <div id="controlStatus" class="control-status">
               <div class="status-line">Status: <span id="statusText" class="status-value">Ready</span></div>
               <div class="status-line">Active Viewers: <span id="activeViewers" class="status-value">0</span></div>
               <div class="status-line">Network: <span class="status-value">Connected</span></div>
               
               <!-- Performance Metrics -->
               <div id="performanceMetrics" class="performance-metrics hidden">
                   <div class="metrics-title">üìä Performance</div>
                   <div class="metrics-row">
                       <div class="metric">
                           <div class="metric-label">FPS</div>
                           <div class="metric-value" id="metricFps">0</div>
                       </div>
                       <div class="metric">
                           <div class="metric-label">Latency</div>
                           <div class="metric-value" id="metricLatency">0ms</div>
                       </div>
                       <div class="metric">
                           <div class="metric-label">Dropped</div>
                           <div class="metric-value" id="metricDropped">0</div>
                       </div>
                       <div class="metric">
                           <div class="metric-label">CPU</div>
                           <div class="metric-value" id="metricCpu">0%</div>
                       </div>
                   </div>
                   <div class="encoder-info" id="encoderInfo">Encoder: Unknown</div>
               </div>
           </div>
          
           <div>
               <button id="startStreamBtn" class="btn btn-success btn-lg">
                   <span id="startBtnText">üöÄ Start Screen Sharing</span>
                   <span id="startLoading" class="loading hidden">‚è≥</span>
               </button>
           </div>
       </div>
   </div>
  
   <!-- Stream Viewer -->
   <div id="streamViewer" class="stream-viewer">
       <video id="videoView" autoplay muted playsinline></video>
       
       <!-- ‚è±Ô∏è Stream Timer - Top Right Corner -->
       <div id="streamTimestamp" class="stream-timestamp">
           <div class="stream-timestamp-row">
               <span class="stream-timestamp-label">üöÄ Started:</span>
               <span id="compactStartTime" class="stream-timestamp-value">--:--:--</span>
           </div>
           <div class="stream-timestamp-row">
               <span class="stream-timestamp-label">‚è±Ô∏è Elapsed:</span>
               <span id="compactElapsedTime" class="stream-timestamp-value elapsed">00:00:00</span>
           </div>
           <div class="stream-timestamp-row">
               <span class="stream-timestamp-label">‚è≥ Remaining:</span>
               <span id="compactCountdown" class="stream-timestamp-value countdown">01:00:00</span>
           </div>
       </div>
       
       <!-- Stream Controls - Bottom Center -->
       <div id="streamControls" class="stream-controls">
           <button id="stopBtn" class="btn btn-danger">
               <span id="stopBtnText">üõë Stop Streaming</span>
               <span id="stopLoading" class="loading hidden">‚è≥</span>
           </button>
       </div>
   </div>
  
   <!-- Error Display -->
   <div id="error" class="error">
       <h3>Connection Error</h3>
       <p id="errorMessage">Unable to connect to the screen sharing server.</p>
       <button onclick="location.reload()" class="btn" style="background: white; color: #e74c3c; margin-top: 10px;">Retry Connection</button>
   </div>
  
   <!-- üïí Session Results (shown on screen after session) -->
   <div id="sessionResults" class="session-results" style="display: none;">
       <h3>üìä Session Completed</h3>
       <div class="session-detail">
           <span class="session-detail-label">üöÄ Started:</span>
           <span id="resultStartTime" class="session-detail-value">--:--:--</span>
       </div>
       <div class="session-detail">
           <span class="session-detail-label">üõë Ended:</span>
           <span id="resultStopTime" class="session-detail-value">--:--:--</span>
       </div>
       <div class="session-detail">
           <span class="session-detail-label">‚è±Ô∏è Duration:</span>
           <span id="resultDuration" class="session-detail-value session-duration">00:00:00</span>
       </div>
       <div class="session-detail">
           <span class="session-detail-label">üìÖ Date:</span>
           <span id="resultDate" class="session-detail-value">--/--/----</span>
       </div>
       <div style="text-align: center; margin-top: 20px;">
           <button class="btn" style="background: linear-gradient(135deg, #7CB342 0%, #558B2F 100%); color: white; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);" onclick="document.getElementById('sessionResults').style.display='none'">Close</button>
       </div>
   </div>
  
   <div id="error" class="error">
       <h3>Connection Error</h3>
       <p id="errorMessage">Unable to connect to the screen sharing server.</p>
       <button onclick="location.reload()">Retry Connection</button>
   </div>


   <script>
       class ScreenAIManager {
           constructor() {
               this.socket = null;
               this.reconnectAttempts = 0;
               this.maxReconnectAttempts = 5;
               this.frameCount = 0;
               this.lastFrameTime = Date.now();
               this.isStreaming = false;
               this.intentionalStop = false;
               
               // Video streaming support
               this.isVideoMode = false;
               this.mediaSource = null;
               this.sourceBuffer = null;
               this.videoQueue = [];
               this.isSourceBufferUpdating = false;
               this.incompleteChunk = null; // Buffer for incomplete fMP4 boxes
              
               // üïí Timestamp tracking
               this.startTime = null;
               this.stopTime = null;
               this.elapsedTimer = null;
               this.countdownTimer = null; // ‚è±Ô∏è Countdown timer
              
               // ‚è±Ô∏è Session duration limit (1 hour = 3600 seconds)
               this.sessionDurationLimit = 3600; // 1 hour in seconds
               this.sessionTimeRemaining = this.sessionDurationLimit;
              
               // Page elements
               this.controlPanel = document.getElementById('controlPanel');
               this.streamViewer = document.getElementById('streamViewer');
              
               // Controls
               this.startStreamBtn = document.getElementById('startStreamBtn');
               this.stopBtn = document.getElementById('stopBtn');
              
               // Stream elements
               this.videoView = document.getElementById('videoView');
               this.errorElement = document.getElementById('error');
               this.errorMessage = document.getElementById('errorMessage');
               this.statusText = document.getElementById('statusText');
               this.activeViewers = document.getElementById('activeViewers');
              
               // Timestamp elements
               this.streamControls = document.getElementById('streamControls');
               this.streamTimestamp = document.getElementById('streamTimestamp');
               this.compactStartTime = document.getElementById('compactStartTime');
               this.compactElapsedTime = document.getElementById('compactElapsedTime');
               this.compactCountdown = document.getElementById('compactCountdown');
               this.stopBtn = document.getElementById('stopBtn');
              
               // Session results elements
               this.sessionResults = document.getElementById('sessionResults');
               this.resultStartTime = document.getElementById('resultStartTime');
               this.resultStopTime = document.getElementById('resultStopTime');
               this.resultDuration = document.getElementById('resultDuration');
               this.resultDate = document.getElementById('resultDate');
              
               // State variables
               this.initSegmentReceived = false;
               this.waitingForInit = true;
               this.videoStarted = false;
              
               // Event listeners
               this.startStreamBtn.addEventListener('click', () => this.startStreaming());
               this.stopBtn.addEventListener('click', () => this.stopStreaming());
              
               this.startFrameRateCounter();
               this.resetTimestamps();
               this.showControlPanel(); // Start with control center
           }
          
           // Navigation Methods
           showControlPanel() {
               this.controlPanel.style.display = 'flex';
               this.streamViewer.style.display = 'none';
               this.hideError();
               this.updateControlStatus('Ready');
               document.body.style.overflow = 'auto';
               
               // Clean up any remaining video resources
               this.cleanupVideoStreaming();
           }
          
           showStreamViewer() {
               this.controlPanel.style.display = 'none';
               this.streamViewer.style.display = 'block';
               this.isStreaming = true;
               document.body.style.overflow = 'hidden';
           }
          
           startFrameRateCounter() {
               setInterval(() => {
                   const now = Date.now();
                   const timeDiff = now - this.lastFrameTime;
                   if (timeDiff > 5000 && this.isStreaming) { // No frames for 5 seconds
                       this.updateStreamStatus('No frames received', 'disconnected');
                   }
               }, 1000);
           }
          
           async startStreaming() {
               this.setButtonLoading(this.startStreamBtn, 'startBtnText', 'startLoading', true);
              
               try {
                   console.log('Starting streaming...');
                   this.updateControlStatus('Starting...');
                  
                   // Call API to start capture
                   const response = await fetch('/api/start-capture');
                   const result = await response.json();
                   console.log('API response:', result);
                  
                   if (result.success) {
                       this.updateControlStatus('Connecting...');
                       // Switch to stream viewer and start WebSocket
                       this.showStreamViewer();
                       this.connectWebSocket();
                   } else {
                       this.showError(`Failed to start: ${result.message}`);
                   }
               } catch (error) {
                   console.error('Start streaming error:', error);
                   this.showError(`Network error: ${error.message}`);
               } finally {
                   this.setButtonLoading(this.startStreamBtn, 'startBtnText', 'startLoading', false);
               }
           }
          
           connectWebSocket() {
               const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
               const wsUrl = `${protocol}//${window.location.host}/screenshare`;
               console.log('Connecting to WebSocket:', wsUrl);
              
               this.socket = new WebSocket(wsUrl);
              
               this.socket.onopen = async () => {
                   console.log('WebSocket connected successfully!');
                   this.updateStreamStatus('Connected', 'connected');
                   this.hideError();
                   this.reconnectAttempts = 0;
                  
                   // üé¨ Initialize H.264 MediaSource for video streaming
                   console.log('üé¨ Initializing MediaSource for H.264 streaming...');
                   try {
                       await this.initializeH264Video();
                       console.log('‚úÖ MediaSource initialized successfully');
                   } catch (error) {
                       console.error('‚ùå Failed to initialize MediaSource:', error);
                       this.showError('Failed to initialize video player');
                   }
                  
                   // üïí Initialize timestamps when connected
                   this.initializeTimestamps();
               };
              
               this.socket.onmessage = async (event) => {
                   // Enhanced debugging for all message types
                   console.log('üåê WebSocket message received:', {
                       dataType: typeof event.data,
                       constructor: event.data.constructor.name,
                       isArrayBuffer: event.data instanceof ArrayBuffer,
                       isBlob: event.data instanceof Blob,
                       size: event.data.byteLength || event.data.size || event.data.length || 'unknown'
                   });
                   
                   if (event.data instanceof ArrayBuffer) {
                       // Binary H.264 video data
                       console.log(`üìπ Received H.264 ArrayBuffer: ${event.data.byteLength} bytes`);
                       const view = new Uint8Array(event.data, 0, Math.min(16, event.data.byteLength));
                       console.log('üîç First 16 bytes:', Array.from(view).map(b => b.toString(16).padStart(2, '0')).join(' '));
                       
                       await this.handleBinaryVideoData(event.data);
                       
                   } else if (event.data instanceof Blob) {
                       // Handle Blob data by converting to ArrayBuffer
                       console.log(`üìπ Received H.264 Blob: ${event.data.size} bytes, type: ${event.data.type}`);
                       try {
                           const buffer = await event.data.arrayBuffer();
                           console.log(`üìπ Converted Blob to ArrayBuffer: ${buffer.byteLength} bytes`);
                           await this.handleBinaryVideoData(buffer);
                       } catch (error) {
                           console.error('‚ùå Failed to convert Blob to ArrayBuffer:', error);
                       }
                   } else {
                       // Text JSON messages (control messages only)
                       console.log(`üì© Received text message: ${event.data}`);
                       try {
                           const message = JSON.parse(event.data);
                           this.handleMessage(message);
                       } catch (error) {
                           console.error('‚ùå Failed to parse WebSocket message:', error);
                       }
                   }
               };
              
               this.socket.onclose = (event) => {
                   console.log('WebSocket closed - Code:', event.code, 'Reason:', event.reason);
                   this.updateStreamStatus('Disconnected', 'disconnected');
                   
                   // Clean up video resources
                   this.cleanupVideoStreaming();
                  
                   // üïí Finalize timestamps when connection closes unexpectedly
                   if (this.isStreaming && !this.intentionalStop) {
                       this.finalizeTimestamps();
                       // Don't auto-reconnect, just show results on home
                       setTimeout(() => {
                           this.showControlPanel();
                       }, 2000);
                   }
               };
              
               this.socket.onerror = (error) => {
                   console.error('WebSocket error occurred:', error);
                   this.updateStreamStatus('Connection Error', 'disconnected');
                   this.showError('Failed to connect to screen sharing server. Please check your connection.');
               };
           }
          
           // üïí Timestamp Management
           initializeTimestamps() {
               console.log('üïí Initializing timestamps...');
               this.startTime = new Date();
               this.stopTime = null;
               this.isStreaming = true;
              
               // Show stream controls and timestamp
               this.streamControls.classList.add('show');
               this.streamTimestamp.classList.add('show');
               this.stopBtn.style.display = 'inline-block';
              
               // Update start time
               this.compactStartTime.textContent = this.formatTime(this.startTime);
              
               // Hide session results
               this.sessionResults.style.display = 'none';
              
               // Start elapsed timer
               this.startElapsedTimer();
              
               // ‚è±Ô∏è Start countdown timer (1 hour limit)
               this.startCountdownTimer();
              
               console.log('üïí Session started at:', this.formatDateTime(this.startTime));
               console.log('üïí Stream controls visible:', this.streamControls.classList.contains('show'));
               console.log('üïí Timestamp element visible:', this.streamTimestamp.style.display);
           }
          
           finalizeTimestamps() {
               this.stopTime = new Date();
               this.isStreaming = false;
              
               // Stop elapsed timer
               if (this.elapsedTimer) {
                   clearInterval(this.elapsedTimer);
                   this.elapsedTimer = null;
               }
              
               // ‚è±Ô∏è Stop countdown timer
               if (this.countdownTimer) {
                   clearInterval(this.countdownTimer);
                   this.countdownTimer = null;
               }
              
               // Hide stream controls
               this.streamControls.classList.remove('show');
               this.streamTimestamp.classList.remove('show');
               this.stopBtn.style.display = 'none';
              
               // Show session results on home screen
               this.showSessionResultsOnHome();
              
               console.log('üïí Session ended at:', this.formatDateTime(this.stopTime));
               console.log('üìä Total session duration:', this.formatDuration(this.stopTime - this.startTime));
           }
          
           startElapsedTimer() {
               this.elapsedTimer = setInterval(() => {
                   if (this.startTime && this.isStreaming) {
                       const elapsed = new Date() - this.startTime;
                       this.compactElapsedTime.textContent = this.formatDuration(elapsed);
                   }
               }, 1000); // Update every second
           }
          
           // ‚è±Ô∏è Countdown Timer (1 hour session limit with auto-stop)
           startCountdownTimer() {
               // Reset countdown
               this.sessionTimeRemaining = this.sessionDurationLimit;
               this.updateCountdownDisplay();
              
               this.countdownTimer = setInterval(() => {
                   if (this.isStreaming && this.sessionTimeRemaining > 0) {
                       this.sessionTimeRemaining--;
                       this.updateCountdownDisplay();
                      
                       // Console warnings at key milestones
                       if (this.sessionTimeRemaining === 600) { // 10 minutes
                           console.warn('‚è∞ 10 minutes remaining until auto-stop');
                       } else if (this.sessionTimeRemaining === 300) { // 5 minutes
                           console.warn('‚è∞ 5 minutes remaining until auto-stop');
                       } else if (this.sessionTimeRemaining === 60) { // 1 minute
                           console.warn('‚è∞ 1 minute remaining until auto-stop');
                       }
                      
                       // Auto-stop when timer reaches 0
                       if (this.sessionTimeRemaining === 0) {
                           console.warn('‚è∞ Session time limit reached - Auto-stopping stream');
                           this.autoStopStream();
                       }
                   }
               }, 1000); // Update every second
           }
          
           updateCountdownDisplay() {
               const countdownElement = this.compactCountdown;
               countdownElement.textContent = this.formatDuration(this.sessionTimeRemaining * 1000);
              
               // Visual warnings based on time remaining
               countdownElement.classList.remove('warning', 'critical');
              
               if (this.sessionTimeRemaining <= 60) { // ‚â§ 1 minute - Critical (red)
                   countdownElement.classList.add('critical');
               } else if (this.sessionTimeRemaining <= 300) { // ‚â§ 5 minutes - Warning (orange)
                   countdownElement.classList.add('warning');
               }
               // else - Normal (blue) - default
           }
          
           // Auto-stop stream when countdown reaches 0
           async autoStopStream() {
               console.log('üõë Auto-stopping stream after 1 hour session limit...');
               this.intentionalStop = true;
               this.autoStopped = true; // Flag to show in session results
              
               try {
                   // Call API to stop capture
                   const response = await fetch('/api/stop-capture');
                   const result = await response.json();
                  
                   if (result.success) {
                       console.log('‚úÖ Auto-stop completed successfully');
                       this.finalizeTimestamps();
                       this.cleanupVideoStreaming();
                      
                       if (this.socket) {
                           this.socket.close();
                           this.socket = null;
                       }
                      
                       this.showControlPanel();
                       this.isStreaming = false;
                   }
               } catch (error) {
                   console.error('‚ùå Auto-stop error:', error);
                   this.finalizeTimestamps();
               } finally {
                   setTimeout(() => {
                       this.intentionalStop = false;
                   }, 100);
               }
           }
          
           showSessionResults() {
               if (!this.startTime || !this.stopTime) return;
              
               const duration = this.stopTime - this.startTime;
              
               // Populate session results
               this.resultStartTime.textContent = this.formatTime(this.startTime);
               this.resultStopTime.textContent = this.formatTime(this.stopTime);
               this.resultDuration.textContent = this.formatDuration(duration);
               this.resultDate.textContent = this.formatDate(this.startTime);
              
               // Show session results
               this.sessionResults.style.display = 'block';
              
               // Update title if auto-stopped
               const titleElement = this.sessionResults.querySelector('h3');
               if (this.autoStopped) {
                   titleElement.textContent = '‚è∞ Session Auto-Stopped (1 Hour Limit)';
                   titleElement.style.color = '#FF9800';
               } else {
                   titleElement.textContent = 'üìä Session Completed';
                   titleElement.style.color = '#8BC34A';
               }
              
               // Log detailed summary to console
               console.log('üìä Complete Session Summary:', {
                   startTime: this.formatDateTime(this.startTime),
                   stopTime: this.formatDateTime(this.stopTime),
                   duration: this.formatDuration(duration),
                   durationMs: duration,
                   date: this.formatDate(this.startTime),
                   autoStopped: this.autoStopped || false,
                   userAgent: navigator.userAgent,
                   timestamp: new Date().toISOString()
               });
              
               // Auto-hide after 30 seconds
               setTimeout(() => {
                   this.hideSessionResults();
               }, 30000);
           }
          
           hideSessionResults() {
               this.sessionResults.style.display = 'none';
               this.resetTimestamps();
           }
          
           showSessionResultsOnHome() {
               // Ensure we're on the control panel first
               this.showControlPanel();
               // Then show session results overlay
               setTimeout(() => {
                   this.showSessionResults();
               }, 100);
           }
          
           resetTimestamps() {
               this.startTime = null;
               this.stopTime = null;
               this.isStreaming = false;
               this.autoStopped = false; // Reset auto-stop flag
              
               if (this.elapsedTimer) {
                   clearInterval(this.elapsedTimer);
                   this.elapsedTimer = null;
               }
              
               // ‚è±Ô∏è Stop countdown timer
               if (this.countdownTimer) {
                   clearInterval(this.countdownTimer);
                   this.countdownTimer = null;
               }
              
               // Reset countdown time
               this.sessionTimeRemaining = this.sessionDurationLimit;
              
               // Reset display values
               this.compactStartTime.textContent = '--:--:--';
               this.compactElapsedTime.textContent = '00:00:00';
               this.compactCountdown.textContent = '01:00:00';
               this.compactCountdown.classList.remove('warning', 'critical');
              
               // Hide elements
               this.streamControls.classList.remove('show');
               this.streamTimestamp.classList.remove('show');
               this.stopBtn.style.display = 'none';
               this.sessionResults.style.display = 'none';
           }
          
           formatTime(date) {
               return date.toLocaleTimeString([], {
                   hour: '2-digit',
                   minute: '2-digit',
                   second: '2-digit',
                   hour12: false
               });
           }
          
           formatDateTime(date) {
               return date.toLocaleString([], {
                   year: 'numeric',
                   month: '2-digit',
                   day: '2-digit',
                   hour: '2-digit',
                   minute: '2-digit',
                   second: '2-digit',
                   hour12: false
               });
           }
          
           formatDuration(milliseconds) {
               const totalSeconds = Math.floor(milliseconds / 1000);
               const hours = Math.floor(totalSeconds / 3600);
               const minutes = Math.floor((totalSeconds % 3600) / 60);
               const seconds = totalSeconds % 60;
              
               return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
           }
          
           formatDate(date) {
               return date.toLocaleDateString([], {
                   year: 'numeric',
                   month: '2-digit',
                   day: '2-digit'
               });
           }
          
           async stopStreaming() {
               this.setButtonLoading(this.stopBtn, 'stopBtnText', 'stopLoading', true);
               this.intentionalStop = true;
              
               try {
                   console.log('üõë Stopping streaming session...');
                  
                   // Call API to stop capture
                   const response = await fetch('/api/stop-capture');
                   const result = await response.json();
                  
                   if (result.success) {
                       console.log('‚úÖ Capture stopped successfully');
                      
                       // üïí Finalize timestamps when stopping
                       this.finalizeTimestamps();
                      
                       // Clean up video resources
                       this.cleanupVideoStreaming();
                       
                       // Close WebSocket
                       if (this.socket) {
                           this.socket.close();
                           this.socket = null;
                       }
                      
                       // Return to control center immediately to show session results
                       this.showControlPanel();
                       this.isStreaming = false;
                      
                   } else {
                       console.error('Failed to stop:', result.message);
                       this.showError(`Failed to stop: ${result.message}`);
                   }
               } catch (error) {
                   console.error('‚ùå Stop streaming error:', error);
                   this.finalizeTimestamps();
                   this.showError(`Network error: ${error.message}`);
               } finally {
                   this.setButtonLoading(this.stopBtn, 'stopBtnText', 'stopLoading', false);
                   setTimeout(() => {
                       this.intentionalStop = false;
                   }, 100);
               }
           }
          
           setButtonLoading(button, textId, loadingId, loading) {
               const textElement = document.getElementById(textId);
               const loadingElement = document.getElementById(loadingId);
              
               if (loading) {
                   textElement.classList.add('hidden');
                   loadingElement.classList.remove('hidden');
                   button.disabled = true;
               } else {
                   textElement.classList.remove('hidden');
                   loadingElement.classList.add('hidden');
                   button.disabled = false;
               }
           }
          


          
           /**
            * Initialize MediaSource for H.264 video streaming with enhanced compatibility
            */
           async initializeH264Video() {
               console.log('üé¨ Initializing H.264 MediaSource...');
               
               if (!window.MediaSource) {
                   console.error('‚ùå MediaSource API not supported');
                   this.showError('Browser does not support H.264 video streaming');
                   return false;
               }

               try {
                   // Clean up existing MediaSource
                   if (this.mediaSource && this.mediaSource.readyState !== 'closed') {
                       console.log('üîÑ Cleaning up existing MediaSource...');
                       try {
                           if (this.sourceBuffer && !this.sourceBuffer.updating) {
                               this.mediaSource.removeSourceBuffer(this.sourceBuffer);
                           }
                           if (this.mediaSource.readyState === 'open') {
                               this.mediaSource.endOfStream();
                           }
                       } catch (e) {
                           console.log('‚ö†Ô∏è MediaSource cleanup warning:', e.message);
                       }
                   }

                   // Check codec support - prioritize fMP4 to match JavaCV output
                   const supportedCodecs = [
                       'video/mp4; codecs="avc1.42E01E"',    // fMP4 with H.264 Baseline - matches JavaCV
                       'video/mp4; codecs="avc1.4D401E"',    // fMP4 with H.264 Main fallback
                       'video/mp4; codecs="avc1.640028"'     // fMP4 with H.264 High fallback
                   ];
                   
                   console.log('üîç Checking codec support:');
                   let codecUsed = null;
                   for (const codec of supportedCodecs) {
                       const isSupported = MediaSource.isTypeSupported(codec);
                       console.log(`  ${codec}: ${isSupported ? '‚úÖ' : '‚ùå'}`);
                       if (isSupported && !codecUsed) {
                           codecUsed = codec;
                       }
                   }
                   
                   if (!codecUsed) {
                       console.error('‚ùå No supported H.264 codec found');
                       this.showError('Browser does not support required H.264 codecs');
                       return false;
                   }

                   // Create new MediaSource
                   this.mediaSource = new MediaSource();
                   this.videoView.src = URL.createObjectURL(this.mediaSource);
                   
                   return new Promise((resolve, reject) => {
                       this.mediaSource.addEventListener('sourceopen', async () => {
                           console.log('üéØ MediaSource opened successfully');
                           
                           try {
                               this.sourceBuffer = this.mediaSource.addSourceBuffer(codecUsed);
                               console.log('üé• SourceBuffer created with codec:', codecUsed);
                               
                               // Configure SourceBuffer for low latency
                               this.sourceBuffer.mode = 'sequence';
                               
                               this.sourceBuffer.addEventListener('updateend', () => {
                                   console.log('üì¶ SourceBuffer update completed');
                                   
                                   // Low-latency buffer management: keep only last 2 seconds
                                   const currentTime = this.videoView.currentTime;
                                   const buffered = this.sourceBuffer.buffered;
                                   
                                   if (buffered.length > 0) {
                                       const bufferStart = buffered.start(0);
                                       const bufferEnd = buffered.end(buffered.length - 1);
                                       
                                       // Remove old buffer (keep last 2 seconds)
                                       if (bufferEnd - bufferStart > 2 && currentTime - bufferStart > 2) {
                                           try {
                                               this.sourceBuffer.remove(bufferStart, currentTime - 2);
                                               console.debug('üßπ Trimmed old buffer for low latency');
                                               return; // Don't process pending chunks yet
                                           } catch (e) {
                                               console.debug('Buffer trim skipped:', e.message);
                                           }
                                       }
                                   }
                                   
                                   this.processVideoQueue();
                               });
                               
                               this.sourceBuffer.addEventListener('error', (e) => {
                                   console.error('‚ùå SourceBuffer error:', e);
                                   console.error('   SourceBuffer details:', {
                                       updating: this.sourceBuffer.updating,
                                       bufferedRanges: this.sourceBuffer.buffered.length,
                                       mode: this.sourceBuffer.mode,
                                       timestampOffset: this.sourceBuffer.timestampOffset
                                   });
                                   console.error('   MediaSource details:', {
                                       readyState: this.mediaSource.readyState,
                                       duration: this.mediaSource.duration
                                   });
                                   this.showError('H.264 SourceBuffer error - check console for details');
                               });
                               
                               // Configure video element for low latency
                               this.videoView.muted = true;
                               this.videoView.autoplay = true;
                               this.videoView.playsInline = true;
                               
                               // Low latency video settings
                               if ('fastSeek' in this.videoView) {
                                   this.videoView.fastSeek = true;
                               }
                               
                               console.log('üé¨ H.264 video streaming ready!');
                               this.isVideoMode = true;
                               this.switchToVideoView();
                               
                               resolve(true);
                               
                           } catch (error) {
                               console.error('‚ùå Failed to create SourceBuffer:', error);
                               reject(error);
                           }
                       });
                       
                       this.mediaSource.addEventListener('sourceended', () => {
                           console.log('üìπ MediaSource ended');
                       });
                       
                       this.mediaSource.addEventListener('error', (e) => {
                           console.error('‚ùå MediaSource error:', e);
                           reject(e);
                       });
                   });
                   
               } catch (error) {
                   console.error('‚ùå Failed to initialize H.264 MediaSource:', error);
                   this.showError('H.264 initialization failed: ' + error.message);
                   return false;
               }
           }
           
           /**
            * Enhanced video queue processing with low latency optimization
            */
           processVideoQueue() {
               // Limit pending queue to prevent buildup
               if (this.videoQueue.length > 5) {
                   console.warn('‚ö†Ô∏è Dropping old chunks to reduce latency');
                   this.videoQueue.shift(); // Drop oldest chunk
               }
               
               if (this.videoQueue.length > 0 && this.sourceBuffer && !this.sourceBuffer.updating) {
                   const data = this.videoQueue.shift();
                   try {
                       this.sourceBuffer.appendBuffer(data);
                       console.log('üì¶ Queued H.264 data processed:', data.byteLength, 'bytes');
                       
                       // Keep video playback as close to live as possible
                       if (this.videoView.buffered.length > 0) {
                           const bufferEnd = this.videoView.buffered.end(this.videoView.buffered.length - 1);
                           const currentTime = this.videoView.currentTime;
                           
                           // If we're falling behind by more than 0.5 seconds, jump forward
                           if (bufferEnd - currentTime > 0.5) {
                               this.videoView.currentTime = bufferEnd - 0.2;
                               console.debug('‚ö° Jumped to live edge, latency:', (bufferEnd - currentTime).toFixed(2), 's');
                           }
                       }
                   } catch (error) {
                       console.error('‚ùå Error processing queued data:', error);
                   }
               }
           }
           
           /**
            * MediaSource recovery function
            */
           async reinitializeMediaSource() {
               console.log('üîÑ Reinitializing MediaSource for recovery...');
               try {
                   await this.initializeH264Video();
                   console.log('‚úÖ MediaSource recovered successfully');
               } catch (error) {
                   console.error('‚ùå Failed to recover MediaSource:', error);
               }
           }

           /**
            * Parse fMP4 boxes from data and return complete boxes
            */
           parseFMP4Boxes(uint8Array) {
               const boxes = [];
               let offset = 0;
               
               while (offset < uint8Array.length) {
                   if (offset + 8 > uint8Array.length) {
                       // Not enough data for a box header
                       break;
                   }
                   
                   // Read box size (big-endian 32-bit integer)
                   const boxSize = (uint8Array[offset] << 24) |
                                 (uint8Array[offset + 1] << 16) |
                                 (uint8Array[offset + 2] << 8) |
                                  uint8Array[offset + 3];
                   
                   // Read box type
                   const boxType = String.fromCharCode(
                       uint8Array[offset + 4],
                       uint8Array[offset + 5],
                       uint8Array[offset + 6],
                       uint8Array[offset + 7]
                   );
                   
                   if (boxSize === 0) {
                       // Box extends to end of file
                       boxes.push({
                           type: boxType,
                           size: uint8Array.length - offset,
                           offset: offset
                       });
                       break;
                   }
                   
                   if (boxSize < 8) {
                       console.error('Invalid box size:', boxSize, 'at offset:', offset);
                       break;
                   }
                   
                   if (offset + boxSize > uint8Array.length) {
                       // Incomplete box
                       break;
                   }
                   
                   boxes.push({
                       type: boxType,
                       size: boxSize,
                       offset: offset
                   });
                   
                   offset += boxSize;
               }
               
               return {
                   boxes: boxes,
                   bytesConsumed: offset,
                   hasIncompleteBox: offset < uint8Array.length
               };
           }
           
           /**
            * Check if boxes contain initialization segment
            */
           hasInitBoxes(boxes) {
               return boxes.some(box => box.type === 'ftyp' || box.type === 'moov');
           }

           /**
            * Check if data contains initialization segment (ftyp and moov boxes)
            */
           containsInitSegment(uint8Array) {
               if (uint8Array.length < 8) return false;
               
               let offset = 0;
               let hasFtyp = false;
               let hasMoov = false;
               
               while (offset + 8 <= uint8Array.length) {
                   const boxSize = (uint8Array[offset] << 24) |
                                 (uint8Array[offset + 1] << 16) |
                                 (uint8Array[offset + 2] << 8) |
                                  uint8Array[offset + 3];
                   
                   const boxType = String.fromCharCode(
                       uint8Array[offset + 4],
                       uint8Array[offset + 5],
                       uint8Array[offset + 6],
                       uint8Array[offset + 7]
                   );
                   
                   if (boxType === 'ftyp') hasFtyp = true;
                   if (boxType === 'moov') hasMoov = true;
                   
                   if (boxSize < 8 || offset + boxSize > uint8Array.length) break;
                   offset += boxSize;
               }
               
               return hasFtyp && hasMoov;
           }

           /**
            * Get box information for debugging
            */
           getBoxInfo(uint8Array) {
               if (uint8Array.length < 8) return 'too small';
               
               const boxes = [];
               let offset = 0;
               
               while (offset + 8 <= uint8Array.length && boxes.length < 5) {
                   const boxSize = (uint8Array[offset] << 24) |
                                 (uint8Array[offset + 1] << 16) |
                                 (uint8Array[offset + 2] << 8) |
                                  uint8Array[offset + 3];
                   
                   const boxType = String.fromCharCode(
                       uint8Array[offset + 4],
                       uint8Array[offset + 5],
                       uint8Array[offset + 6],
                       uint8Array[offset + 7]
                   );
                   
                   boxes.push(`${boxType}(${boxSize})`);
                   
                   if (boxSize < 8 || offset + boxSize > uint8Array.length) break;
                   offset += boxSize;
               }
               
               return boxes.join(', ') || 'unknown';
           }

           /**
            * Handle binary H.264 video data from WebSocket with ultra-low latency optimization
            * Process fMP4 container with H.264 for MediaSource API
            */
           async handleBinaryVideoData(data) {
               if (!data || data.byteLength === 0) {
                   console.warn('‚ö†Ô∏è Received empty data');
                   return;
               }

               try {
                   const uint8Data = new Uint8Array(data);
                   
                   // Check for initialization segment
                   const hasInit = this.containsInitSegment(uint8Data);
                   const boxInfo = this.getBoxInfo(uint8Data);
                   
                   console.log(`üé• Received fMP4 chunk: ${uint8Data.length} bytes, boxes: ${boxInfo}, hasInit: ${hasInit}`);
                   
                   // CRITICAL: Must receive init segment first
                   if (!this.initSegmentReceived && !hasInit) {
                       console.warn('‚ö†Ô∏è Waiting for initialization segment, dropping media data');
                       return;
                   }
                   
                   if (hasInit) {
                       console.log('‚úÖ Initialization segment detected');
                       this.initSegmentReceived = true;
                       this.waitingForInit = false;
                   }
                   
                   // Append to SourceBuffer
                   if (!this.sourceBuffer || this.sourceBuffer.updating) {
                       if (this.videoQueue.length >= 10) {
                           console.warn('‚ö†Ô∏è Queue full, dropping oldest chunk');
                           this.videoQueue.shift();
                       }
                       this.videoQueue.push(uint8Data);
                       console.log(`üì¶ Queued (${this.videoQueue.length} pending)`);
                       return;
                   }
                   
                   // Validate SourceBuffer is still attached to MediaSource
                   if (!this.mediaSource || this.mediaSource.readyState === 'closed' || 
                       !this.mediaSource.sourceBuffers.length) {
                       console.warn('‚ö†Ô∏è MediaSource not ready or closed, queuing data');
                       this.videoQueue.push(uint8Data);
                       return;
                   }
                   
                   try {
                       this.isAppending = true;
                       this.sourceBuffer.appendBuffer(uint8Data);
                       console.log(`‚úÖ Appended ${uint8Data.length} bytes to SourceBuffer`);
                   } catch (appendError) {
                       console.error('‚ùå Failed to append to SourceBuffer:', appendError);
                       this.isAppending = false;
                       
                       // If SourceBuffer was removed, try to reinitialize
                       if (appendError.name === 'InvalidStateError') {
                           console.log('üîÑ Attempting to reinitialize MediaSource...');
                           this.reinitializeMediaSource();
                       }
                       return;
                   }
                   
                   // Auto-play when we have enough data
                   if (!this.videoStarted && this.sourceBuffer.buffered.length > 0) {
                       setTimeout(() => {
                           this.videoView.play().then(() => {
                               console.log('‚ñ∂Ô∏è Video playback started');
                               this.videoStarted = true;
                           }).catch(e => {
                               console.warn('‚ö†Ô∏è Autoplay prevented, click video to play');
                           });
                       }, 100);
                   }
                   
               } catch (error) {
                   console.error('‚ùå Error handling video data:', error);
                   console.error('Stack:', error.stack);
                   this.showError(`Video processing error: ${error.message}`);
               }
           }

           /**
            * Create MP4 fragment from raw H.264 data for MediaSource API
            * This wraps raw H.264 NAL units in MP4 container format
            */
           createMP4Fragment(h264Data) {
               try {
                   // For simplicity, we'll try to feed raw H.264 directly to MediaSource
                   // and let the browser handle the containerization if possible
                   console.log('üîß Creating MP4 fragment from raw H.264 data');
                   
                   // Check if this is valid H.264 data by looking for NAL units
                   let hasNalUnits = false;
                   for (let i = 0; i < h264Data.length - 3; i++) {
                       if (h264Data[i] === 0x00 && h264Data[i + 1] === 0x00 && 
                           h264Data[i + 2] === 0x00 && h264Data[i + 3] === 0x01) {
                           hasNalUnits = true;
                           break;
                       }
                   }
                   
                   if (!hasNalUnits) {
                       console.error('‚ùå No valid H.264 NAL units found in data');
                       return null;
                   }
                   
                   console.log('‚úÖ Valid H.264 NAL units detected, returning raw data for direct processing');
                   return h264Data.buffer;
                   
               } catch (error) {
                   console.error('‚ùå Error creating MP4 fragment:', error);
                   return null;
               }
           }

           /**
            * Process video data immediately for ultra-low latency (bypasses queue)
            */
           processVideoDataImmediate(videoData) {
               try {
                   if (this.sourceBuffer && !this.sourceBuffer.updating) {
                       this.isSourceBufferUpdating = true;
                       this.sourceBuffer.appendBuffer(videoData);
                   } else {
                       // Fallback to queue if buffer is busy
                       this.videoQueue.push(videoData);
                   }
               } catch (error) {
                   console.error('Error in immediate video processing:', error);
                   this.videoQueue.push(videoData); // Fallback to queue
               }
           }
           processVideoDataImmediate(videoData) {
               try {
                   this.isSourceBufferUpdating = true;
                   this.sourceBuffer.appendBuffer(videoData);
                   
                   // Manage buffer size for low latency
                   this.manageBufferSize();
                   
               } catch (error) {
                   console.error('Error in immediate video processing:', error);
                   this.isSourceBufferUpdating = false;
                   // Fallback to queue processing
                   this.videoQueue.push(videoData);
                   this.processVideoQueue();
               }
           }

           /**
            * Process queued video data with latency optimizations
            */
           processVideoQueue() {
               if (this.isSourceBufferUpdating || this.videoQueue.length === 0 || !this.sourceBuffer) {
                   return;
               }
               
               // Validate MediaSource and SourceBuffer are still valid
               if (!this.mediaSource || this.mediaSource.readyState === 'closed' || 
                   !this.mediaSource.sourceBuffers.length) {
                   console.warn('‚ö†Ô∏è MediaSource closed during queue processing, clearing queue');
                   this.videoQueue = [];
                   return;
               }
               
               try {
                   const videoData = this.videoQueue.shift();
                   
                   if (this.sourceBuffer.updating) {
                       // For ultra-low latency, drop frame instead of re-queuing
                       console.debug('Dropping frame to maintain low latency');
                       return;
                   }
                   
                   this.isSourceBufferUpdating = true;
                   this.sourceBuffer.appendBuffer(videoData);
                   
                   // Manage buffer to prevent accumulation
                   this.manageBufferSize();
                   
               } catch (error) {
                   console.error('Error appending video data:', error);
                   this.videoQueue = []; // Clear entire queue on error
                   this.isSourceBufferUpdating = false;
               }
           }

           /**
            * Manage buffer size to maintain ultra-low latency
            */
           manageBufferSize() {
               if (!this.sourceBuffer || this.sourceBuffer.updating) {
                   return;
               }
               
               try {
                   const buffered = this.sourceBuffer.buffered;
                   if (buffered.length > 0) {
                       const currentTime = this.videoView.currentTime;
                       const bufferedEnd = buffered.end(buffered.length - 1);
                       
                       // Remove old data if buffer gets too large (keep only last 2 seconds)
                       if (bufferedEnd - currentTime > 2) {
                           const removeEnd = currentTime - 0.5; // Keep 0.5s before current time
                           if (removeEnd > 0) {
                               this.sourceBuffer.remove(0, removeEnd);
                           }
                       }
                   }
               } catch (error) {
                   console.debug('Buffer management error (non-critical):', error);
               }
           }

           /**
            * Initialize video display for H.264 streaming
            */
           switchToVideoView() {
               this.controlPanel.style.display = 'none';
               this.streamViewer.style.display = 'block';
               this.videoView.style.display = 'block';
               
               console.log('üé¨ Switched to H.264 video view');
               console.log('üì∫ Video element ready:', {
                   width: this.videoView.videoWidth,
                   height: this.videoView.videoHeight,
                   readyState: this.videoView.readyState,
                   paused: this.videoView.paused
               });
           }



           /**
            * Clean up video streaming resources
            */
           cleanupVideoStreaming() {
               console.log('Cleaning up video streaming resources');
               
               // Stop video playback
               if (this.videoView) {
                   this.videoView.pause();
                   this.videoView.src = '';
                   this.videoView.load();
               }
               
               // Clean up MediaSource
               if (this.mediaSource) {
                   if (this.mediaSource.readyState === 'open') {
                       try {
                           if (this.sourceBuffer && !this.sourceBuffer.updating) {
                               this.mediaSource.removeSourceBuffer(this.sourceBuffer);
                           }
                           this.mediaSource.endOfStream();
                       } catch (error) {
                           console.debug('Error during MediaSource cleanup:', error);
                       }
                   }
                   
                   // Revoke object URL to free memory
                   if (this.videoView.src) {
                       URL.revokeObjectURL(this.videoView.src);
                   }
               }
               
               // Reset state
               this.videoQueue = [];
               this.sourceBuffer = null;
               this.mediaSource = null;
               this.isSourceBufferUpdating = false;
               this.isVideoMode = false;
               
               // Hide video element
               this.videoView.style.display = 'none';
           }

           handleMessage(message) {
               switch (message.type) {
                   case 'connected':
                       console.log('Server acknowledged connection');
                       break;
                   
                   case 'viewerCount':
                       // Update active viewers count
                       if (this.activeViewers && message.count !== undefined) {
                           this.activeViewers.textContent = message.count;
                           console.log(`üë• Active viewers updated: ${message.count}`);
                       }
                       break;
                   
                   case 'performance':
                       // Update performance metrics
                       this.updatePerformanceMetrics(message.metrics);
                       break;
                      
                   case 'frame':
                       // Legacy JPEG frame support removed - H.264 only
                       console.warn('Received legacy JPEG frame - ignoring (H.264-only mode)');
                       break;
                      
                   default:
                       console.log('Unknown message type:', message.type);
               }
           }
           
           updatePerformanceMetrics(metrics) {
               if (!metrics) return;
               
               // Show metrics panel if hidden
               const metricsPanel = document.getElementById('performanceMetrics');
               if (metricsPanel && metricsPanel.classList.contains('hidden')) {
                   metricsPanel.classList.remove('hidden');
               }
               
               // Update FPS
               const fpsElement = document.getElementById('metricFps');
               if (fpsElement) {
                   fpsElement.textContent = metrics.fps.toFixed(1);
               }
               
               // Update Latency
               const latencyElement = document.getElementById('metricLatency');
               if (latencyElement) {
                   latencyElement.textContent = `${metrics.latencyMs}ms`;
               }
               
               // Update Dropped Frames
               const droppedElement = document.getElementById('metricDropped');
               if (droppedElement) {
                   const dropRate = metrics.dropRate.toFixed(1);
                   droppedElement.textContent = `${metrics.droppedFrames} (${dropRate}%)`;
                   // Change color if drop rate is high
                   if (metrics.dropRate > 5) {
                       droppedElement.style.color = '#FF5722';
                   } else {
                       droppedElement.style.color = '#8BC34A';
                   }
               }
               
               // Update CPU Usage
               const cpuElement = document.getElementById('metricCpu');
               if (cpuElement) {
                   cpuElement.textContent = `${metrics.cpuUsage.toFixed(1)}%`;
               }
               
               // Update Encoder Info
               const encoderElement = document.getElementById('encoderInfo');
               if (encoderElement) {
                   encoderElement.textContent = `Encoder: ${metrics.encoderType}`;
               }
               
               console.log(`üìä Performance: FPS=${metrics.fps.toFixed(1)}, Latency=${metrics.latencyMs}ms, Dropped=${metrics.droppedFrames}, CPU=${metrics.cpuUsage.toFixed(1)}%`);
           }
          
           updateStreamStatus(text, className) {
               // Status boxes removed - can optionally use console logging
               console.log(`Stream Status: ${text} (${className})`);
           }
          
           updateControlStatus(text) {
               if (this.statusText) {
                   this.statusText.textContent = text;
               }
           }
          
           showError(message) {
               this.errorMessage.textContent = message;
               this.errorElement.style.display = 'block';
           }
          
           hideError() {
               this.errorElement.style.display = 'none';
           }
          
           attemptReconnect() {
               if (this.reconnectAttempts < this.maxReconnectAttempts && !this.intentionalStop) {
                   this.reconnectAttempts++;
                   const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                  
                   this.updateStreamStatus(`Reconnecting in ${Math.ceil(delay/1000)}s... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'connecting');
                  
                   setTimeout(() => {
                       this.updateStreamStatus('Reconnecting...', 'connecting');
                       this.connectWebSocket();
                   }, delay);
               } else if (!this.intentionalStop) {
                   this.showError('Failed to reconnect after multiple attempts. Please try again.');
               }
           }
       }
      
       // Initialize ScreenAI Manager when page loads
       document.addEventListener('DOMContentLoaded', () => {
           window.screenAI = new ScreenAIManager();
       });
   </script>
</body>
</html>



