<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenAI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            b        <div style="padding: 10px; color: white; text-align: center;">
            <!-- üïí Stream Timestamp -->
            <div id="streamTimestamp" class="stream-timestamp" style="display: none;">
                <div class="stream-timestamp-row">
                    <span class="stream-timestamp-label">Started:</span>
                    <span id="compactStartTime" class="stream-timestamp-value">--:--:--</span>
                </div>
                <div class="stream-timestamp-row">
                    <span class="stream-timestamp-label">Elapsed:</span>
                    <span id="compactElapsedTime" class="stream-timestamp-value elapsed">00:00:00</span>
                </div>
            </div>
            
            <button id="stopBtn" class="btn btn-danger">
                <span id="stopBtnText">üõë Stop Streaming</span>
                <span id="stopLoading" class="loading hidden">‚è≥</span>
            </button>
        </div>box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .control-panel {
            text-align: center;
            padding: 30px;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .control-panel h1 {
            margin-bottom: 20px;
            font-size: 2.2em;
        }
        
        .status {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 400px;
        }
        
        .status-line {
            margin: 8px 0;
            font-size: 16px;
        }
        
        .status-value {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .btn {
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s;
            min-width: 180px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: #27ae60;
            color: white;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .stream-container {
            text-align: center;
            background: #000;
            padding: 20px;
        }
        
        .stream-container img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 20px;
            text-align: center;
            display: none;
        }
        
        .loading {
            display: inline-block;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none !important;
        }

        /* üïí Stream Timestamp Styles */
        .stream-timestamp {
            display: inline-block;
            margin-right: 20px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.2;
            vertical-align: middle;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .stream-timestamp-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 2px 0;
        }

        .stream-timestamp-label {
            font-size: 10px;
            opacity: 0.8;
            min-width: 40px;
        }

        .stream-timestamp-value {
            color: #4CAF50;
            font-weight: bold;
        }

        .stream-timestamp-value.elapsed {
            color: #FF9800;
            font-size: 12px;
        }

        /* Session Summary on Home Screen */
        .session-results {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 12px;
            margin: 20px auto;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .session-results h3 {
            color: #4CAF50;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        .session-detail {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .session-detail:last-child {
            border-bottom: none;
        }

        .session-detail-label {
            opacity: 0.9;
            font-weight: 500;
        }

        .session-detail-value {
            color: #4CAF50;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .session-duration {
            color: #FF9800 !important;
            font-size: 16px !important;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .stream-timestamp {
                display: block;
                margin: 0 auto 15px auto;
                font-size: 10px;
                padding: 6px 10px;
            }
            
            .stream-timestamp-value.elapsed {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <!-- Control Panel -->
    <div id="controlPanel" class="control-panel">
        <h1>üé• ScreenAI Viewer</h1>
        
        <div id="status" class="status">
            <div class="status-line">Status: <span id="statusText" class="status-value">Ready</span></div>
            <div class="status-line">Viewers: <span id="viewerCount" class="status-value">0</span></div>
        </div>
        
        <div>
            <button id="startBtn" class="btn btn-success">
                <span id="startBtnText">üöÄ Start Streaming</span>
                <span id="startLoading" class="loading hidden">‚è≥</span>
            </button>
        </div>
    </div>
    
    <!-- Error Display -->
    <div id="error" class="error">
        <h3>Error</h3>
        <p id="errorMessage">Something went wrong.</p>
        <button onclick="location.reload()" class="btn" style="background: white; color: #e74c3c; margin-top: 10px;">Retry</button>
    </div>
    
    <!-- Stream Container -->
    <div id="streamContainer" class="stream-container hidden">
        <img id="screenView" alt="Screen Stream" />
        <div style="padding: 10px; color: white; text-align: center;">
            <!-- üïí Compact Stream Timestamp -->
            <div id="streamTimestamp" class="stream-timestamp" style="display: none;">
                <div class="stream-timestamp-row">
                    <span class="stream-timestamp-label">Started:</span>
                    <span id="compactStartTime" class="stream-timestamp-value">--:--:--</span>
                </div>
                <div class="stream-timestamp-row">
                    <span class="stream-timestamp-label">Elapsed:</span>
                    <span id="compactElapsedTime" class="stream-timestamp-value elapsed">00:00:00</span>
                </div>
            </div>
            
            <button id="stopBtn" class="btn btn-danger">
                <span id="stopBtnText">ÔøΩ Stop Streaming</span>
                <span id="stopLoading" class="loading hidden">‚è≥</span>
            </button>
        </div>
    </div>

    <!-- üïí Session Results (shown on home screen after session) -->
    <div id="sessionResults" class="session-results" style="display: none;">
        <h3>üìä Session Completed</h3>
        <div class="session-detail">
            <span class="session-detail-label">üöÄ Started:</span>
            <span id="resultStartTime" class="session-detail-value">--:--:--</span>
        </div>
        <div class="session-detail">
            <span class="session-detail-label">üõë Ended:</span>
            <span id="resultStopTime" class="session-detail-value">--:--:--</span>
        </div>
        <div class="session-detail">
            <span class="session-detail-label">‚è±Ô∏è Duration:</span>
            <span id="resultDuration" class="session-detail-value session-duration">00:00:00</span>
        </div>
        <div class="session-detail">
            <span class="session-detail-label">üìÖ Date:</span>
            <span id="resultDate" class="session-detail-value">--/--/----</span>
        </div>
    </div>

    <script>
        class SimpleViewer {
            constructor() {
                this.socket = null;
                this.isStreaming = false;
                this.intentionalStop = false;
                
                // üïí Timestamp tracking
                this.startTime = null;
                this.stopTime = null;
                this.elapsedTimer = null;
                
                // Get DOM elements
                this.controlPanel = document.getElementById('controlPanel');
                this.streamContainer = document.getElementById('streamContainer');
                this.screenView = document.getElementById('screenView');
                this.statusText = document.getElementById('statusText');
                this.viewerCount = document.getElementById('viewerCount');
                this.errorDiv = document.getElementById('error');
                this.errorMessage = document.getElementById('errorMessage');
                
                // üïí Timestamp elements
                this.streamTimestamp = document.getElementById('streamTimestamp');
                this.compactStartTime = document.getElementById('compactStartTime');
                this.compactElapsedTime = document.getElementById('compactElapsedTime');
                
                // Session results elements
                this.sessionResults = document.getElementById('sessionResults');
                this.resultStartTime = document.getElementById('resultStartTime');
                this.resultStopTime = document.getElementById('resultStopTime');
                this.resultDuration = document.getElementById('resultDuration');
                this.resultDate = document.getElementById('resultDate');
                
                // Buttons
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                
                // Event listeners
                this.startBtn.addEventListener('click', () => this.startStreaming());
                this.stopBtn.addEventListener('click', () => this.stopStreaming());
                
                // Initialize
                this.updateStatus('Ready');
                this.resetTimestamps();
            }
            
            // üïí Timestamp Management
            initializeTimestamps() {
                this.startTime = new Date();
                this.stopTime = null;
                
                // Show compact timestamp in stream view
                this.streamTimestamp.style.display = 'inline-block';
                
                // Update compact start time
                this.compactStartTime.textContent = this.formatTime(this.startTime);
                
                // Hide session results on home screen
                this.sessionResults.style.display = 'none';
                
                // Start elapsed timer
                this.startElapsedTimer();
                
                console.log('üïí Session started at:', this.formatDateTime(this.startTime));
            }
            
            finalizeTimestamps() {
                this.stopTime = new Date();
                
                // Stop elapsed timer
                if (this.elapsedTimer) {
                    clearInterval(this.elapsedTimer);
                    this.elapsedTimer = null;
                }
                
                // Hide compact timestamp in stream view
                this.streamTimestamp.style.display = 'none';
                
                // Show session results on home screen
                this.showSessionResults();
                
                console.log('üïí Session ended at:', this.formatDateTime(this.stopTime));
                console.log('üìä Total session duration:', this.formatDuration(this.stopTime - this.startTime));
            }
            
            startElapsedTimer() {
                this.elapsedTimer = setInterval(() => {
                    if (this.startTime && this.isStreaming) {
                        const elapsed = new Date() - this.startTime;
                        this.compactElapsedTime.textContent = this.formatDuration(elapsed);
                    }
                }, 1000); // Update every second
            }
            
            showSessionResults() {
                if (!this.startTime || !this.stopTime) return;
                
                const duration = this.stopTime - this.startTime;
                
                // Populate session results
                this.resultStartTime.textContent = this.formatTime(this.startTime);
                this.resultStopTime.textContent = this.formatTime(this.stopTime);
                this.resultDuration.textContent = this.formatDuration(duration);
                this.resultDate.textContent = this.formatDate(this.startTime);
                
                // Show session results on home screen
                this.sessionResults.style.display = 'block';
                
                // Log detailed summary to console
                console.log('üìä Complete Session Summary:', {
                    startTime: this.formatDateTime(this.startTime),
                    stopTime: this.formatDateTime(this.stopTime),
                    duration: this.formatDuration(duration),
                    durationMs: duration,
                    date: this.formatDate(this.startTime),
                    userAgent: navigator.userAgent,
                    timestamp: new Date().toISOString()
                });
                
                // Auto-hide after 30 seconds
                setTimeout(() => {
                    this.hideSessionResults();
                }, 30000);
            }
            
            hideSessionResults() {
                this.sessionResults.style.display = 'none';
                this.resetTimestamps();
            }
            
            resetTimestamps() {
                this.startTime = null;
                this.stopTime = null;
                
                if (this.elapsedTimer) {
                    clearInterval(this.elapsedTimer);
                    this.elapsedTimer = null;
                }
                
                // Reset compact timestamp display
                this.compactStartTime.textContent = '--:--:--';
                this.compactElapsedTime.textContent = '00:00:00';
                
                // Hide elements
                this.streamTimestamp.style.display = 'none';
                this.sessionResults.style.display = 'none';
            }
            
            formatTime(date) {
                return date.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }
            
            formatDateTime(date) {
                return date.toLocaleString([], {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }
            
            formatDuration(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            formatDate(date) {
                return date.toLocaleDateString([], {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
            }
            
            async startStreaming() {
                this.setButtonLoading(this.startBtn, 'startBtnText', 'startLoading', true);
                
                try {
                    console.log('üöÄ Initiating streaming session...');
                    // Call API to start capture
                    const response = await fetch('/api/start-capture');
                    const result = await response.json();
                    console.log('üì° API response:', result);
                    
                    if (result.success) {
                        this.updateStatus('Starting...');
                        
                        // üïí Initialize timestamps when streaming starts
                        this.initializeTimestamps();
                        
                        // Start WebSocket connection
                        this.connectWebSocket();
                    } else {
                        this.showError(`Failed to start: ${result.message}`);
                    }
                } catch (error) {
                    console.error('‚ùå Start streaming error:', error);
                    this.showError(`Network error: ${error.message}`);
                } finally {
                    this.setButtonLoading(this.startBtn, 'startBtnText', 'startLoading', false);
                }
            }
            
            async stopStreaming() {
                this.setButtonLoading(this.stopBtn, 'stopBtnText', 'stopLoading', true);
                this.intentionalStop = true;
                
                try {
                    console.log('üõë Stopping streaming session...');
                    
                    // Call API to stop capture
                    const response = await fetch('/api/stop-capture');
                    const result = await response.json();
                    
                    if (result.success) {
                        console.log('‚úÖ Capture stopped successfully');
                        
                        // üïí Finalize timestamps when stopping
                        this.finalizeTimestamps();
                        
                        // Close WebSocket and return to dashboard
                        if (this.socket) {
                            this.socket.close();
                            this.socket = null;
                        }
                        this.backToDashboard();
                    } else {
                        this.showError(`Failed to stop: ${result.message}`);
                    }
                } catch (error) {
                    console.error('‚ùå Stop streaming error:', error);
                    this.showError(`Network error: ${error.message}`);
                    // Still finalize timestamps even on error
                    this.finalizeTimestamps();
                } finally {
                    this.setButtonLoading(this.stopBtn, 'stopBtnText', 'stopLoading', false);
                    // Reset the flag after a small delay to ensure onclose handler has finished
                    setTimeout(() => {
                        this.intentionalStop = false;
                    }, 100);
                }
            }
            
            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/screenshare`;
                console.log('Connecting to WebSocket:', wsUrl);
                
                this.socket = new WebSocket(wsUrl);
                
                this.socket.onopen = () => {
                    console.log('‚úÖ WebSocket connected successfully!');
                    this.updateStatus('Connected');
                    this.showStream();
                };
                
                this.socket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        if (message.type === 'frame') {
                            this.screenView.src = message.data;
                            this.updateStatus('Streaming');
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to parse WebSocket message:', error);
                    }
                };
                
                this.socket.onclose = (event) => {
                    console.log('üîå WebSocket closed - Code:', event.code);
                    this.updateStatus('Disconnected');
                    
                    // Only handle as unexpected disconnection if streaming and not intentional
                    if (this.isStreaming && !this.intentionalStop) {
                        console.warn('‚ö†Ô∏è Unexpected disconnection during streaming');
                        // Finalize timestamps on unexpected disconnection
                        this.finalizeTimestamps();
                        this.showError('Connection lost. Please try again.');
                    }
                };
                
                this.socket.onerror = (error) => {
                    console.error('‚ùå WebSocket error:', error);
                };
            }
            
            showStream() {
                console.log('üé¨ Switching to stream view');
                this.isStreaming = true;
                this.controlPanel.classList.add('hidden');
                this.streamContainer.classList.remove('hidden');
            }
            
            backToDashboard() {
                this.isStreaming = false;
                this.controlPanel.classList.remove('hidden');
                this.streamContainer.classList.add('hidden');
                this.hideError();
                this.updateStatus('Ready');
                
                // Don't close socket here if it's already closed or being closed intentionally
                if (this.socket && !this.intentionalStop) {
                    this.socket.close();
                    this.socket = null;
                }
            }
            
            updateStatus(status) {
                this.statusText.textContent = status;
            }
            
            showError(message) {
                this.errorMessage.textContent = message;
                this.errorDiv.style.display = 'block';
            }
            
            hideError() {
                this.errorDiv.style.display = 'none';
            }
            
            setButtonLoading(button, textId, loadingId, loading) {
                const textElement = document.getElementById(textId);
                const loadingElement = document.getElementById(loadingId);
                
                if (loading) {
                    textElement.classList.add('hidden');
                    loadingElement.classList.remove('hidden');
                    button.disabled = true;
                } else {
                    textElement.classList.remove('hidden');
                    loadingElement.classList.add('hidden');
                    button.disabled = false;
                }
            }
            
            // üïí Get current session information
            getSessionInfo() {
                if (!this.startTime) return null;
                
                const now = new Date();
                const currentStopTime = this.stopTime || now;
                const duration = currentStopTime - this.startTime;
                
                return {
                    startTime: this.startTime,
                    stopTime: this.stopTime,
                    duration: duration,
                    isActive: this.isStreaming,
                    formattedStart: this.formatDateTime(this.startTime),
                    formattedStop: this.stopTime ? this.formatDateTime(this.stopTime) : 'Still streaming',
                    formattedDuration: this.formatDuration(duration)
                };
            }
        }
        
        // Initialize viewer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.viewer = new SimpleViewer();
            console.log('üé¨ ScreenAI Viewer Timestamps initialized');
        });
    </script>
</body>
</html>
